/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package main.java.logic.parser;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Vector;

import main.java.QPar;
import main.java.logic.Visitor;
import main.java.logic.heuristic.DependencyNode;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;

// All nodes in the formula tree are derived from SimpleNode.
public class SimpleNode implements Node, Serializable {

	static Logger logger = Logger.getLogger(SimpleNode.class);
		
	protected Object value;
	protected Qbf_parser parser;
	protected Node parent;
	public Node[] children;
	public NodeType nodeType = null;

	public int id;				
	public int var = -1;			// -1 = not a var node
//	public String op = "";			// "" = not an operator node
//	public String truthValue = "";	// "" = not truth assigned
	public enum NodeType {
		START, VAR, FORALL, EXISTS, AND, OR, NOT, TRUE, FALSE
	}

	/**
	 * constructor
	 */
	public SimpleNode() {
	}

	public void setNodeType(NodeType nt) {
		this.nodeType = nt;
	}

	public NodeType getNodeType() {
		return nodeType;
	}

	public int getNodeVariable() {
		return var;
	}

	public void setNodeVariable(int v) {
		this.var = v;
	}
	
	public void accept(Visitor v) {
		v.visit(this);
	}
	
	
	/**
	 * assign a truth value to a specific var
	 * 
	 * @param v
	 *            the var to assign a truth value to
	 * @param b
	 *            the truth value to assign
	 */
	public ArrayList<SimpleNode> assignTruthValue(int v, boolean b) {
		int numChildren = this.jjtGetNumChildren();
		
		ArrayList<SimpleNode> assigned = new ArrayList<SimpleNode>();
		// not in a leaf node, nothing to set
		if (nodeType != NodeType.VAR) {
			for (int i = 0; i < numChildren; i++) {
				assigned.addAll(jjtGetChild(i).assignTruthValue(v, b));
			}
		}
		// in the right leaf node now
		else {
			if ((var == v) && (nodeType == NodeType.VAR)) {
				assigned.add(this);
				if (b) {
					nodeType = NodeType.TRUE;
				} else {
					nodeType = NodeType.FALSE;
				}
			}
		}
		return assigned;
	}

	/**
	 * Checks if a node is somehow connected to the root node.
	 * 
	 * @return True if there's a path from this node to the root, false
	 *         otherwise
	 */
	public boolean checkConnectionToRoot() {
		// this might be the root node itself, so obviously there's a connection
		if (this.getClass().getName().equals("main.java.logic.parser.ASTInput"))
			return true;

		// the node may also be an orphan, so no connection to root
		if (this.jjtGetParent() == null)
			return false;

		// or, if the node is neither root itself nor orphaned, check the parent
		return this.jjtGetParent().checkConnectionToRoot();
	}

	/**
	 * Collects negative literals as long as they're children of nodes with the
	 * given && or || operator
	 * 
	 * @return A vector of negative literals
	 * @param op
	 *            The operator the negative literals should be children of
	 * @param v
	 *            A vector of all already collected negative literals
	 */
	public Vector<Integer> getPositiveLiterals(NodeType op, Vector<Integer> v) {
		for (int i = 0; i < this.jjtGetNumChildren(); i++) {
			// if the child is a var node, just add the var number
			if ((this.jjtGetChild(i)).getNodeType() == NodeType.VAR) {
				v.add(this.jjtGetChild(i).getNodeVariable());
			}

			// nested con/disjunction, go deeper in the tree and collect
			// literals there
			if (this.jjtGetChild(i).getNodeType() == op) {
				v = (this.jjtGetChild(i).getPositiveLiterals(op, v));
			}
		}
		return v;
	}

	/**
	 * Collects positive literals as long as they're children of nodes with the
	 * given && or || operator
	 * 
	 * @return A vector of positive literals
	 * @param op
	 *            The operator the positive literals should be children of
	 * @param v
	 *            A vector of all already collected positive literals
	 */
	public Vector<Integer> getNegativeLiterals(NodeType op, Vector<Integer> v) {
		for (int i = 0; i < this.jjtGetNumChildren(); i++) {
			// if the child is a var node, just add the var number
			if (this.jjtGetChild(i).getNodeType() == NodeType.NOT) {
				v.add(this.jjtGetChild(i).jjtGetChild(0).getNodeVariable());
			}

			// nested con/disjunction, go deeper in the tree and collect
			// literals there
			if (this.jjtGetChild(i).getNodeType() == op) {
				v = (this.jjtGetChild(i).getNegativeLiterals(op, v));
			}
		}
		return v;
	}

	/**
	 * This gets enclosed formulas
	 * 
	 * @return A qpro formatted subformula
	 * @param op
	 *            ICH KENN MICH GRAD SELBST NICHT MEHR AUS :) TODO
	 */
	public String getEnclosedFormula(NodeType op) {
		String tmp = "";
		for (int i = 0; i < this.jjtGetNumChildren(); i++) {
			if (this.jjtGetChild(i).getNodeType() == op) {
				tmp += this.jjtGetChild(i).traverse();
			} else if ((this.jjtGetChild(i).getNodeType() == NodeType.EXISTS) || 
			           (this.jjtGetChild(i).getNodeType() == NodeType.FORALL)) {
				tmp += jjtGetChild(i).traverse();
			} else {
				tmp += this.jjtGetChild(i).getEnclosedFormula(op);
			}
		}
		return tmp;
	}

	/**
	 * Returns a dependency Tree
	 */
	public DependencyNode[] dependencyTree() {
		DependencyNode dn = null;
		switch(this.nodeType) {
			case START:
				dn = new DependencyNode(0, DependencyNode.NodeType.ROOT);
			case FORALL:
				if(dn == null)
					dn = new DependencyNode(this.getVar(), DependencyNode.NodeType.UNIVERSAL);
			case EXISTS:
				if(dn == null)
					dn = new DependencyNode(this.getVar(), DependencyNode.NodeType.EXISTENTIAL);
				
				DependencyNode[] kids = ((SimpleNode)children[0]).dependencyTree();		
				assert(kids.length <= 2);
				
				for(DependencyNode d : kids) {
					dn.addChild(d);
				}
				
				if(dn.type == DependencyNode.NodeType.ROOT)
					dn.setDepth(0);
				DependencyNode[] ret = {dn};
				return ret;
			case NOT:
				return ((SimpleNode)children[0]).dependencyTree();
			case VAR:
				return new DependencyNode[0];
			case AND:
			case OR:
				ArrayList<DependencyNode> ret1 = new ArrayList<DependencyNode>();
				
				DependencyNode[] d1 = ((SimpleNode)children[0]).dependencyTree();
				DependencyNode[] d2 = ((SimpleNode)children[1]).dependencyTree();
				if(d1.length > 0) {
					ret1.add(d1[0]);
				}
				if(d2.length > 0) {
					ret1.add(d2[0]);
				}
				
				return ret1.toArray(new DependencyNode[ret1.size()]);
			default:
				assert(false);
				return null;
		}
	}
	
	/**
	 * traverse tree goes through all children of a node and builds a String in
	 * .qpro format
	 * 
	 * @return A String in qpro format
	 */
	public String traverse() {
//		Node child;
//		String tmp = "";
//		String[] tmpList;
		String traversedTree = "";
//		String partialTree = "";
//		String negatedPartialTree = "";
//		String enclosedPartialTree = "";
		Vector<Integer> posLiterals = new Vector<Integer>();
		Vector<Integer> negLiterals = new Vector<Integer>();
		SimpleNode tmpNode = null;
		
		if (nodeType == NodeType.EXISTS) {
			NodeType nt = jjtGetParent().getNodeType(); 	
			if (nt != NodeType.FORALL)
				traversedTree += "q\n";
			traversedTree += "e ";

			// add the first var
			traversedTree += var + " ";
			
			tmpNode = (SimpleNode)this.jjtGetChild(0);

			while (tmpNode.getNodeType() == NodeType.EXISTS) {
				traversedTree += tmpNode.getVar() + " ";
				tmpNode = (SimpleNode)tmpNode.jjtGetChild(0);
			}
			traversedTree += "\n";
			traversedTree += tmpNode.traverse();
			if ((nt != NodeType.EXISTS) && (nt != NodeType.FORALL))
				traversedTree += "/q\n";
			
		}	
			
		if (nodeType == NodeType.FORALL) {
			NodeType nt = jjtGetParent().getNodeType(); 	
			if (nt != NodeType.EXISTS)
				traversedTree += "q\n";
			traversedTree += "a ";

			// add the first var
			traversedTree += var + " ";
			
			tmpNode = (SimpleNode)this.jjtGetChild(0);

			while (tmpNode.getNodeType() == NodeType.FORALL) {
				traversedTree += tmpNode.getVar() + " ";
				tmpNode = (SimpleNode)tmpNode.jjtGetChild(0);
			}
			traversedTree += "\n";
			traversedTree += tmpNode.traverse();
			if ((nt != NodeType.EXISTS) && (nt != NodeType.FORALL))
				traversedTree += "/q\n";
		}	
			
		if (nodeType == NodeType.AND) {
			/*
			 *if ((jjtGetParent().getNodeType() == NodeType.FORALL) || (jjtGetParent().getNodeType() == NodeType.EXISTS))
			 *    traversedTree += "\n";
			 */
			traversedTree += "c\n";
			posLiterals = (this.getPositiveLiterals(NodeType.AND, posLiterals));
			negLiterals = (this.getNegativeLiterals(NodeType.AND, negLiterals));

			for (int var : posLiterals)
				traversedTree += var + " ";
			traversedTree += "\n";

			for (int var : negLiterals)
				traversedTree += var + " ";
			traversedTree += "\n";

			traversedTree += this.getEnclosedFormula(NodeType.OR);

			traversedTree += "/c\n";
		}

		if (nodeType == NodeType.OR) {
			/*
			 *if ((jjtGetParent().getNodeType() == NodeType.FORALL) || (jjtGetParent().getNodeType() == NodeType.EXISTS))
			 *    traversedTree += "\n";
			 */
			traversedTree += "d\n";
			posLiterals = (this.getPositiveLiterals(NodeType.OR, posLiterals));
			negLiterals = (this.getNegativeLiterals(NodeType.OR, negLiterals));

			for (int var : posLiterals)
				traversedTree += var + " ";
			traversedTree += "\n";

			for (int var : negLiterals)
				traversedTree += var + " ";
			traversedTree += "\n";

			traversedTree += this.getEnclosedFormula(NodeType.AND);

			traversedTree += "/d\n";
		}

		return traversedTree;
	}

	/**
	 * reduces a tree containing truth-assigned variables to a tree without them
	 * 
	 * @return true if tree is still traversable, false if not
	 */
	public boolean reduce() {
		Node parentNode = null;
		Node grandparentNode = null;
		Node siblingNode = null;
		int i = 0;
		boolean reducable = false;
		
		if (this.jjtGetNumChildren() > 0) { // we're not in a leaf node...
			for (i = 0; i < this.jjtGetNumChildren(); i++) { // ... so we just
																// traverse
																// through all
																// it's children
				if (jjtGetChild(i).checkConnectionToRoot())
					reducable = jjtGetChild(i).reduce() || reducable;
			}
		} else { // we're in a leaf node...
			parentNode = this.jjtGetParent();
			if ((nodeType == NodeType.TRUE) || (nodeType == NodeType.FALSE)) {
				// we're in a truth-assigned leaf node now, let's see what to do

				// if we're in the logical root node, then there's no more
				// reducing
				// even if it has a truth value assigned, else the tree might be
				// even more reducable
				if (parentNode.getClass().getName().equals(
						"main.java.logic.parser.ASTInput")) {
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("RETURNING FALSE");
					return false;
				}

				if (parentNode.getNodeType() == NodeType.FORALL)
					return false;

				if (parentNode.getNodeType() == NodeType.EXISTS)
					return false;
				
				reducable = true;

				// not x, set the parent to not x
				if (parentNode.getNodeType() == NodeType.NOT) {
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("NEGATION occured");
//					parentNode.setOp("");
					if (nodeType == NodeType.FALSE) {
						parentNode.setNodeType(NodeType.TRUE);
					} else {
						parentNode.setNodeType(NodeType.FALSE);
					}
					parentNode.deleteChildren();
					jjtSetParent(null);
					return reducable;
				}

				// false & x = false, so set parent to false and make it a leaf
				// node
				if ((parentNode.getNodeType() == NodeType.AND) && (nodeType == NodeType.FALSE)) {
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("AND FALSE occured");
					parentNode.setTruthValue(false);
					parentNode.deleteChildren();
					jjtSetParent(null);
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("AND FALSE occured end");
					return reducable;
				}

				// true & x = x, so delete this node, replace the parent node
				// with
				// the sibling
				if ((parentNode.getNodeType() == NodeType.AND) && (nodeType == NodeType.TRUE)) {
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("AND TRUE occured");
					// get grandparent
					grandparentNode = parentNode.jjtGetParent();
					// find sibling
					for (i = 0; i < parentNode.jjtGetNumChildren(); i++) {
						if (parentNode.jjtGetChild(i) != this) {
							siblingNode = parentNode.jjtGetChild(i);
						}
					}
					// make sibling grandparents child
					grandparentNode.replaceChild(parentNode, siblingNode);
					// make grandparent siblings parent
					siblingNode.jjtSetParent(grandparentNode);
					// remove old parents children and parent
					parentNode.deleteChildren();
					parentNode.jjtSetParent(null);
					// remove current nodes parent
					jjtSetParent(null);
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("AND TRUE occured end");
					return reducable;
				}

				// false | x = x, so delete this node, replace the parent node
				// with
				// the sibling
				if ((parentNode.getNodeType() == NodeType.OR) && (nodeType == NodeType.FALSE)) {
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("OR FALSE occured");
					// get grandparent
					grandparentNode = parentNode.jjtGetParent();
					// find sibling
					for (i = 0; i < parentNode.jjtGetNumChildren(); i++) {
						if (parentNode.jjtGetChild(i) != this) {
							siblingNode = parentNode.jjtGetChild(i);
						}
					}
					// make sibling grandparents child
					grandparentNode.replaceChild(parentNode, siblingNode);
					// make grandparent siblings parent
					siblingNode.jjtSetParent(grandparentNode);
					// remove old parents children and parent
					parentNode.deleteChildren();
					parentNode.jjtSetParent(null);
					// remove current nodes parent
					jjtSetParent(null);
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("OR FALSE occured end");
					return reducable;
				}

				// true | x = true, so set the parent node to true and make it a
				// leaf
				if ((parentNode.getNodeType() == NodeType.OR) && (nodeType == NodeType.TRUE)) {
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("OR TRUE occured");
//					parentNode.setOp("");
					parentNode.setTruthValue(true);
					parentNode.deleteChildren();
					jjtSetParent(null);
					if(QPar.logLevel == Level.DEBUG)
						logger.debug("OR TRUE occured end");
					return reducable;
				}
			}
		}
		return reducable;
	}

	public boolean isTruthNode() {
		return this.nodeType == NodeType.FALSE || this.nodeType == NodeType.TRUE;
	}
		
	
	
	/**
	 * removes all children of a node by setting the childrens parent to null
	 * and cleaning the children[] array. Hopefully the garbage collector will
	 * really delete them
	 */
	public void deleteChildren() {
		for (int i = 0; i < jjtGetNumChildren(); i++) {
			jjtGetChild(i).jjtSetParent(null);
		}
		children = null;
	}

	/**
	 * replaces node old with node new in the parent list of a node
	 * 
	 * @param oldNode
	 *            the node to be replaced
	 * @param newNode
	 *            the node that will take the old nodes place
	 * @return true if success, false if the node to replace was not found
	 */
	public boolean replaceChild(Node oldNode, Node newNode) {
		for (int i = 0; i < jjtGetNumChildren(); i++) {
			if (jjtGetChild(i) == oldNode) {
				children[i] = newNode;
				return true;
			}
		}
		return false;
	}

	/**
	 * search for at least one occurance of var v in the tree
	 * 
	 * @param v
	 *            the var to search for
	 * @return true if at least one occurance, false otherwise
	 */
//	public boolean findVar(int v) {
//		int i;
//		boolean found = false;
//
//		// as long as we are in any non-VAR nodes, call the childrens findVar()
//		if (this.nodeType != NodeType.VAR) {
//			for (i = 0; i < this.jjtGetNumChildren(); i++) {
//				found = found || this.jjtGetChild(i).findVar(v);
//			}
//		} else {
//			// if we're in a VAR node with the right variable value, we've
//			// found our node
//			if (this.var == v) {
//				found = true;
//			}
//		}
//		return found;
//	}

	// mostly auto-generated stuff from here plus some simple getter/setter
	// methods
//	public void setTruthValue(String t) {
////		this.truthValue = t;
//		if (t.equals("TRUE")) {
//			this.setNodeType(NodeType.TRUE);
//		} else if (t.equals("FALSE")){
//			this.setNodeType(NodeType.FALSE);
//		}
//	}
	
	public void setTruthValue(boolean t) {
		if (t) {
			this.setNodeType(NodeType.TRUE);
		} else {
			this.setNodeType(NodeType.FALSE);
		}
	}

	public boolean getTruth() {
		if (this.getNodeType() == NodeType.TRUE) {
			return true;
		} else if (this.getNodeType() == NodeType.FALSE){
			return false;
		} else {
			assert(false);
			throw new RuntimeException();
		}
	}
	
	public String getTruthValue() {
		if (this.getNodeType() == NodeType.TRUE) {
			return "TRUE";
		} else if (this.getNodeType() == NodeType.FALSE){
			return "FALSE";
		} else {
			assert(false);
			throw new RuntimeException();
		}
	}
	
	public void setVar(int v) {
		assert((nodeType == NodeType.VAR) || (nodeType == NodeType.FORALL) || (nodeType == NodeType.EXISTS));
		this.var = v;
	}

	public int getVar() {
		return var;
	}

	public void setOp(String o) {
//		this.op = o;
		if (o == "&") {
			nodeType = NodeType.AND;
		} else if (o == "|") {
			nodeType = NodeType.OR;
		} else if (o == "!") {
			nodeType = NodeType.NOT;
		} 
	}

//	public String getOp() {
//		return op;
//	}

	public int getId() {
		return id;
	}

	public SimpleNode(int i) {
		id = i;
	}

	public SimpleNode(Qbf_parser p, int i) {
		this(i);
		parser = p;
	}

	public void jjtOpen() {
	}

	public void jjtClose() {
	}

	public void jjtSetParent(Node n) {
		// TODO: Check the need for setting parent to null when deleting children
		//assert(n != null);
		parent = n;
	}

	public Node jjtGetParent() {
		return parent;
	}

	public void jjtAddChild(Node n, int i) {
		assert(n != null);
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
		assert(children.length < 3);
	}

	public Node jjtGetChild(int i) {
		return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	public void jjtSetValue(Object value) {
		this.value = value;
	}

	public Object jjtGetValue() {
		return value;
	}

	/*
	 * You can override these two methods in subclasses of SimpleNode to
	 * customize the way the node appears when the tree is dumped. If your
	 * output uses more than one line you should override toString(String),
	 * otherwise overriding toString() is probably all you need to do.
	 */

	public String toString() {
		String desc;
		if(this.getNodeType() == NodeType.VAR)
			desc = this.getNodeType() + "(" + var + ")";
		else
			desc = this.getNodeType().toString();
		return desc;
	}

	public String toString(String prefix) {
		return prefix + toString();
	}

	/*
	 * Override this method if you want to customize how the node dumps out its
	 * children.
	 */

	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.dump(prefix + " ");
				}
			}
		}
	}

	public double getTruthProbability() {
		if (children != null) {
			if(this.getNodeType() == NodeType.OR){
				assert (children.length == 2);
				return 1-((1-children[0].getTruthProbability())*(1-children[1].getTruthProbability()));
			} else if(this.getNodeType() == NodeType.AND){
				assert (children.length == 2);
				return (children[0].getTruthProbability() * children[1].getTruthProbability());
			} else {
				assert (children.length == 1);				// We are a quantifier node
				return children[0].getTruthProbability();
			}
				
		}
		// We are a leaf(variable) node. So our P(T) = 0.5
		return 0.5;
	}
}

/* JavaCC - OriginalChecksum=cef32be2ff661aba2beb51d59734528b (do not edit this line) */
