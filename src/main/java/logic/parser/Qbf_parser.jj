/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./Qbf_parser.jj */
/*@egen*//* Qbf_parser.jj
 * Parses a quantified boolean formula in QBF Format 1.0
 * as specified at http://www.qbflib.org/boole.html
 *
 *	<input>		::= <exp> EOF
 *	<exp>		::= <NOT> <exp> | <q_set> <exp> | <LP> <exp> <op> <exp> <RP>
 *				| <LP> <exp> <RP> | <VAR>
 *	<q_set> 	::= <quant> <LSP> <var_list> <RSP>
 *	<quant> 	::= <EXISTS> | <FORALL>
 *	<var_list> 	::= <VAR> <var_list> | <VAR>
 *	<op>		::= <OR> | <AND>
 *	<NOT>		::= "!"
 *	<LP>		::= "("
 *	<RP>		::= ")"
 *	<LSP>		::= "["
 *	<RSP>		::= "]"
 *	<OR>		::= "|"
 *	<AND>		::= "&"
 *	<EXISTS> 	::= "exists"
 *	<FORALL> 	::= "forall"
 *	<VAR>		::= {A sequence of non-special ASCII characters} 
 */

options {
	             
//	VISITOR = true;
//	NODE_DEFAULT_VOID=true;
}

PARSER_BEGIN(Qbf_parser)

package main.java.logic.parser;
import java.util.Vector;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.io.*;

public class Qbf_parser/*@bgen(jjtree)*/implements Qbf_parserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTQbf_parserState jjtree = new JJTQbf_parserState();

/*@egen*/

	private static Vector<Integer> eVars = new Vector<Integer>();
	private static Vector<Integer> aVars = new Vector<Integer>();
	private static Vector<Integer> vars  = new Vector<Integer>();
	private static HashMap<Integer, Integer> literalCount  = new HashMap<Integer, Integer>();


	// thomas' wunschkonzert
	// anz variable negiert und nicht negiert
	// 


	public static void main(String[] args) {
		Qbf_parser parser;
		Node root = null;
		try {
			parser = new Qbf_parser(new FileInputStream(args[0]));
		}
		catch (FileNotFoundException e) {
			System.out.println("File not found: " + args[0]);
			return;
		}

		try {
			parser.Input();
			System.out.println("Succesful parse");
			root = parser.jjtree.rootNode();
//			root.dump("");

			// convert internal tree to .qpro format
			String traversedTree = root.traverse();

//			System.out.println("\nQBF\n"+vars.size()+"\n"+traversedTree+"\nQBF\n");
			System.out.println("vars: " + vars);
			System.out.println("all-quantified vars: " + aVars);
			System.out.println("exists-quantified vars: " + eVars);
			System.out.println("hashmap: " + literalCount);
		}
		catch (ParseException e) {
			System.out.println("Parse error");			
			System.out.println(e);
			return;
		}
		catch (TokenMgrError e) {
			System.out.println(e);
			return;
		}

	}
}

PARSER_END(Qbf_parser)

SKIP : {" "}
SKIP : {"\n" | "\r" | "\r\n" }

// terminals
TOKEN : { < AND		: "&" > }
TOKEN : { < OR		: "|" > }
TOKEN : { < NOT		: "!" > }

TOKEN : { < LP		: "(" > }
TOKEN : { < RP		: ")" > }
TOKEN : { < LSP		: "[" > }
TOKEN : { < RSP		: "]" > }

TOKEN : { < EXISTS	: "exists" > }
TOKEN : { < FORALL	: "forall" > }

TOKEN : { < VAR		: (["a"-"z"])(["0"-"9"])+ > }

// non-terminals
// *	<input>		::= <exp> EOF
void Input():
{/*@bgen(jjtree) Input */
  ASTInput jjtn000 = new ASTInput(JJTINPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Input */
        try {
/*@egen*/
	Exp()
	<EOF>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// *	<exp>		::= <NOT> <exp> | <q_set> <exp> | <LP> <exp> <op> <exp> <RP>
// *				| <LP> <exp> <RP> | <VAR>
void Exp():
{/*@bgen(jjtree) Exp */
  ASTExp jjtn000 = new ASTExp(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Exp */
        try {
/*@egen*/
	Not()
	Exp()
	|
	Q_set()
	Exp()
	|
	<LP> { jjtn000.debugInfo = "("; }
	Exp()
	(
		Op()
		Exp()
	)?
	<RP>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { jjtn000.debugInfo = ")"; }
	|
	Var("")
	|
	<EOF>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// *	<q_set> 	::= <quant> <LSP> <var_list> <RSP>
void Q_set():
{/*@bgen(jjtree) Q_set */
        ASTQ_set jjtn000 = new ASTQ_set(JJTQ_SET);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String s;
}
{/*@bgen(jjtree) Q_set */
        try {
/*@egen*/
	s = Quant()
	<LSP> { jjtn000.debugInfo="["; }
	Var(s)
	<RSP>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.debugInfo="]"; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// *	<quant> 	::= <EXISTS> | <FORALL>
String Quant():
{/*@bgen(jjtree) Quant */
  ASTQuant jjtn000 = new ASTQuant(JJTQUANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Quant */
        try {
/*@egen*/
	Exists()/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.op = "e"; return "e"; }
	|
	Forall()/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.op = "f"; return "f"; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// *	<var_list> 	::= <VAR> <var_list> | <VAR>
//void Var_list():
//{}
//{
////	Var()
////	|
////	Var()
//}

// *	<op>		::= <OR> | <AND>
void Op():
{/*@bgen(jjtree) Op */
  ASTOp jjtn000 = new ASTOp(JJTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Op */
        try {
/*@egen*/
	Or()/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { jjtn000.op = "|"; }
	|
	And()/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.op = "&"; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// content nodes
void And():
{/*@bgen(jjtree) And */
  ASTAnd jjtn000 = new ASTAnd(JJTAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) And */
        try {
/*@egen*/       
	<AND>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.op = "&"; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Or():
{/*@bgen(jjtree) Or */
  ASTOr jjtn000 = new ASTOr(JJTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Or */
        try {
/*@egen*/
	<OR>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { jjtn000.op = "|"; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Not():
{/*@bgen(jjtree) Not */
  ASTNot jjtn000 = new ASTNot(JJTNOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Not */
        try {
/*@egen*/
	<NOT>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.op = "!"; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void Exists():
{/*@bgen(jjtree) Exists */
  ASTExists jjtn000 = new ASTExists(JJTEXISTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Exists */
        try {
/*@egen*/
	<EXISTS>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.op = "e"; System.out.println("EXISTSEXISTSEXISTSEXISTSEXISTS" + jjtn000.op + jjtn000.getClass().getName()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Forall():
{/*@bgen(jjtree) Forall */
  ASTForall jjtn000 = new ASTForall(JJTFORALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Forall */
        try {
/*@egen*/
	<FORALL>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.op = "f";}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Var(String s):
{/*@bgen(jjtree) Var */
        ASTVar jjtn000 = new ASTVar(JJTVAR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Var */
        try {
/*@egen*/
	t = <VAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{	// Stripping down the variable name to a number (e.g. "v123" -> 123 and
		// adding it to a vector containing all variable numbers as well as to a
		// vector with all exist- or allquantified variables (that's the reason
		// for the funny String s fallthrough)
		String varName = t.image.replaceAll("[a-z]*","");
		int varNumber = Integer.valueOf(varName).intValue();
		jjtn000.var = varNumber;
		if (s == "e")
			eVars.add(varNumber);
		if (s == "f")
			aVars.add(varNumber);
		if (s == "") {
			
			if (literalCount.get(varNumber) != null) {
				literalCount.put(varNumber, literalCount.get(varNumber) + 1);
			}
			else {
				literalCount.put(varNumber, 1);			
			}	
			if (!vars.contains(varNumber)) {
				vars.add(varNumber);
			}
		}
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
