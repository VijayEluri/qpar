/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Qbf_parser.jj */
/*@egen*//* Qbf_parser.jj
 * Parses a quantified boolean formula in QBF Format 1.0
 * as specified at http://www.qbflib.org/boole.html
 *
 *	<input>		::= <exp> EOF
 *	<exp>		::= <NOT> <exp> | <q_set> <exp> | <LP> <exp> <op> <exp> <RP>
 *				| <LP> <exp> <RP> | <VAR>
 *	<q_set> 	::= <quant> <LSP> <var_list> <RSP>
 *	<quant> 	::= <EXISTS> | <FORALL>
 *	<var_list> 	::= <VAR> <var_list> | <VAR>
 *	<op>		::= <OR> | <AND>
 *	<NOT>		::= "!"
 *	<LP>		::= "("
 *	<RP>		::= ")"
 *	<LSP>		::= "["
 *	<RSP>		::= "]"
 *	<OR>		::= "|"
 *	<AND>		::= "&"
 *	<EXISTS> 	::= "exists"
 *	<FORALL> 	::= "forall"
 *	<VAR>		::= {A sequence of non-special ASCII characters} 
 */

options {
	             
	                         
	STATIC = false;
}

PARSER_BEGIN(Qbf_parser)

package main.java.logic.parser;
import java.util.Vector;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.io.*;
import main.java.logic.parser.SimpleNode.NodeType;

public class Qbf_parser implements/*@bgen(jjtree)*/ Qbf_parserTreeConstants, /*@egen*/ Serializable {/*@bgen(jjtree)*/
  protected JJTQbf_parserState jjtree = new JJTQbf_parserState();

/*@egen*/

	private Vector<Integer> eVars = new Vector<Integer>();
	private Vector<Integer> aVars = new Vector<Integer>();
	private Vector<Integer> vars  = new Vector<Integer>();
	private Vector<SimpleNode> nodesToExpand = new Vector<SimpleNode>();
	private HashMap<Integer, Integer> literalCount  = new HashMap<Integer, Integer>();
	private HashMap<String, Integer> varNames = new HashMap<String, Integer>();
	private int nextVarInt = 2;
	private SimpleNode root;

	public Qbf_parser() {
		jjtree.reset();
	}
	
	public HashMap<Integer, Integer> getLiteralCount() {
		return this.literalCount;
	}

	public Vector<Integer> getEVars() {
		return this.eVars;
	}

	public Vector<Integer> getAVars() {
		return this.aVars;
	}

	public Vector<Integer> getVars() {
		return this.vars;
	}

	public SimpleNode getRootNode() {
		return (SimpleNode)this.jjtree.rootNode();
	}

	// this expands quantifier nodes with more than one variable, e.g.:
	//
	// 	forall [v1 v2 v3] ... (in boole format)
	//
	// so that instead of one single FORALL node containing v1, v2, v3
	// we have three connected nodes for them in our tree representation
	// of the formula.
	//
	// this may be changed or left empty for other input formats.
        public void doPostprocessing() {

                for (SimpleNode n: nodesToExpand) {

                        SimpleNode currentParent = (SimpleNode) n;
			// save the node that we need to connect at the end
                        SimpleNode lastChild = (SimpleNode) n.jjtGetChild(0);
			n.deleteChildren();

                        for (int var: n.getVarList()) {                                
				SimpleNode currentChild = new SimpleNode();
				currentChild.setNodeType(n.getNodeType());
				currentChild.setNodeVariable(var);
				
				currentParent.jjtAddChild((SimpleNode) currentChild, 0);
				currentChild.jjtSetParent((SimpleNode) currentParent);

				currentParent = currentChild;
                        }

			currentParent.jjtAddChild((SimpleNode) lastChild, 0);
			lastChild.jjtSetParent((SimpleNode) currentParent);
			
			n.setVarList(null);
                }
        }

}

PARSER_END(Qbf_parser)

SKIP : {" "}
SKIP : {"\n" | "\r" | "\r\n" | "\t"}

// terminals
TOKEN : { < AND		: "&" > }
TOKEN : { < OR		: "|" > }
TOKEN : { < NOT		: "!" > }

TOKEN : { < LP		: "(" > }
TOKEN : { < RP		: ")" > }
TOKEN : { < LSP		: "[" > }
TOKEN : { < RSP		: "]" > }

TOKEN : { < EXISTS	: "exists" > }
TOKEN : { < FORALL	: "forall" > }

TOKEN : { < VAR		:(["a"-"z"])(["0"-"9"])+ > }

// non-terminals
// *	<input>		::= <exp> EOF
void Input()       :	// Node with one child (Exp())
{/*@bgen(jjtree) Input */
  ASTInput jjtn000 = new ASTInput(JJTINPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Input */
        try {
/*@egen*/
	{ jjtn000.nodeType = NodeType.START; }
	Exp()
	<EOF>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void And()     :	// Node with two children (Exp(), Exp())
{/*@bgen(jjtree) And */
  ASTAnd jjtn000 = new ASTAnd(JJTAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) And */
        try {
/*@egen*/       
	<AND>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Or()    :	// Node with two children (Exp(), Exp())
{/*@bgen(jjtree) Or */
  ASTOr jjtn000 = new ASTOr(JJTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Or */
        try {
/*@egen*/
	<OR>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Not():	// Node with one child (Exp())
{}
{
 	<NOT>
}
void Exists()      :
{}
{
	<EXISTS> //{ jjtThis.op = "e"; }
}

void Forall()      :
{}
{
	<FORALL> //{ jjtThis.op = "f";}
}

void Var()     :
{/*@bgen(jjtree) Var */
        ASTVar jjtn000 = new ASTVar(JJTVAR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Var */
        try {
/*@egen*/
	t = <VAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		int varNumber = 0;
		
		if (varNames.containsKey(t.image)) {
			jjtn000.var = varNames.get(t.image);
		}
		else {
			varNames.put(t.image,nextVarInt);
			jjtn000.var = nextVarInt;
			nextVarInt++;
		}
		
		jjtn000.nodeType = NodeType.VAR;
		varNumber = jjtn000.var;

		if (literalCount.get(varNumber) != null) {
			literalCount.put(varNumber, literalCount.get(varNumber) + 1);
		}
		else {
			literalCount.put(varNumber, 1);			
		}	
		if (!vars.contains(varNumber)) {
			vars.add(varNumber);
		}
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Vector VarList(Vector varList, String s)      :
{
	Token t;
}
{
	t = <VAR>
	{
		if (!varNames.containsKey(t.image)) {
			varNames.put(t.image,nextVarInt);
			nextVarInt++;
		}

		if (s == "e") {
			if (!vars.contains(varNames.get(t.image))) {
				eVars.add(varNames.get(t.image));
			}
		}

		if (s == "f") {
			if (!vars.contains(varNames.get(t.image))) {
				aVars.add(varNames.get(t.image));
			}
		} 	

		varList.add(varNames.get(t.image));
	}
	(VarList(varList, s))?
	
	{
		return varList;
	}
}

// *	<exp>		::= <NOT> <exp> | <q_set> <exp> | <LP> <exp> <op> <exp> <RP>
// *				| <LP> <exp> <RP> | <VAR>
void Exp()      :
{
	String s = "";
	String op = "";
	Vector<Integer> varList;
	Token t;
}
{/*@bgen(jjtree) #Logical( 1) */
        {
          ASTLogical jjtn001 = new ASTLogical(JJTLOGICAL);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		Not() { jjtn001.nodeType = NodeType.NOT; }
		Exp()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/            
	|/*@bgen(jjtree) #Quantifier( 1) */
        {
          ASTQuantifier jjtn002 = new ASTQuantifier(JJTQUANTIFIER);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	(
		(
			s = Quant()
			<LSP>
			//t = <VAR>
			{ varList = new Vector<Integer>(); }
			varList = VarList(varList, s)
			(
				{
					jjtn002.var = varList.get(0);
					varList.remove(0);					

					if (varList.size() > 0) {
						jjtn002.setVarList(varList);
						nodesToExpand.add(jjtn002);
					}

					if (s == "e")
						jjtn002.nodeType = NodeType.EXISTS;
					if (s == "f")
						jjtn002.nodeType = NodeType.FORALL;	
				}
			)
			<RSP>
		)
		Exp()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  1);
          }
        }
/*@egen*/               
	|
	<LP>/*@bgen(jjtree) #Logical(> 1) */
        {
          ASTLogical jjtn003 = new ASTLogical(JJTLOGICAL);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
	(
		Exp()
		(
			(
				"|" { jjtn003.nodeType = NodeType.OR; }
				|
				"&" { jjtn003.nodeType = NodeType.AND; }
			)
			Exp()
		)?
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/               
	<RP>
	|
	Var()
}

// *	<quant> 	::= <EXISTS> | <FORALL>
String Quant()      :
{}
{
	Exists() { return "e"; }
	|
	Forall() { return "f"; }
}

// *	<op>		::= <OR> | <AND>
void Op()      :
{}
{
	Or()
	|
	And()
}

