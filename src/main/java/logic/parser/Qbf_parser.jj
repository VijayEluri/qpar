/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./Qbf_parser.jj */
/*@egen*//* Qbf_parser.jj
 * Parses a quantified boolean formula in QBF Format 1.0
 * as specified at http://www.qbflib.org/boole.html
 *
 *	<input>		::= <exp> EOF
 *	<exp>		::= <NOT> <exp> | <q_set> <exp> | <LP> <exp> <op> <exp> <RP>
 *				| <LP> <exp> <RP> | <VAR>
 *	<q_set> 	::= <quant> <LSP> <var_list> <RSP>
 *	<quant> 	::= <EXISTS> | <FORALL>
 *	<var_list> 	::= <VAR> <var_list> | <VAR>
 *	<op>		::= <OR> | <AND>
 *	<NOT>		::= "!"
 *	<LP>		::= "("
 *	<RP>		::= ")"
 *	<LSP>		::= "["
 *	<RSP>		::= "]"
 *	<OR>		::= "|"
 *	<AND>		::= "&"
 *	<EXISTS> 	::= "exists"
 *	<FORALL> 	::= "forall"
 *	<VAR>		::= {A sequence of non-special ASCII characters} 
 */

options {
	             
	               
	                       
}

PARSER_BEGIN(Qbf_parser)
package main.java.logic.parser;

class Qbf_parser/*@bgen(jjtree)*/implements Qbf_parserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTQbf_parserState jjtree = new JJTQbf_parserState();

/*@egen*/
	public static void main(String args[]) throws ParseException,TokenMgrError {
		Qbf_parser parser = new Qbf_parser(System.in);
		try {
			ASTStart n = parser.Start();
			Qbf_parserVisitor v = new Qbf_parserDumpVisitor();
			n.jjtAccept(v, null);		
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println(e.getMessage());
			System.out.println("Something went wrong while parsing.");
		}		
	}
}
PARSER_END(Qbf_parser)

SKIP : {" "}
SKIP : {"\n" | "\r" | "\r\n" } // Not really necessary, but why not

TOKEN : { < AND		: "&" > }
TOKEN : { < OR		: "|" > }
TOKEN : { < NOT		: "!" > }

TOKEN : { < LP		: "(" > }
TOKEN : { < RP		: ")" > }
TOKEN : { < LSP		: "[" > }
TOKEN : { < RSP		: "]" > }

TOKEN : { < EXISTS	: "exists" > }
TOKEN : { < FORALL	: "forall" > }

TOKEN : { < VAR		: (["a"-"z"])(["0"-"9"])+ > }

ASTStart Start()       :
{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Start */
          try {
/*@egen*/
/*DEBUG*/ {System.out.println("Starting parsing.");} /*DEBUG*/ 
	Expression() 
/*DEBUG*/ {System.out.println("Finished parsing. ");} /*DEBUG*/ 
	<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return jjtn000;}/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

void Quant()       :
{/*@bgen(jjtree) Quant */
  ASTQuant jjtn000 = new ASTQuant(JJTQUANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Quant */
        try {
/*@egen*/
	(
		<FORALL>
		|
		<EXISTS>
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Op()    :
{/*@bgen(jjtree) Op */
  ASTOp jjtn000 = new ASTOp(JJTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Op */
        try {
/*@egen*//*@bgen(jjtree) #Op(> 2) */
        {
          ASTOp jjtn001 = new ASTOp(JJTOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		<AND>
		|
		<OR>
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 2);
          }
        }
/*@egen*/
	       /*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression()            :
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	<VAR>
	|
	<NOT>
	Expression()
	|
	QSet()
	Expression()
	|
	<LP>
	Expression()
	(
		Op()
		Expression()
	)?
//	OpExpression()
	<RP>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Maybe better if that stuff goes directly into the Expression() rule...(?)
void OpExpression() :
{
}
{
	Expression()
	(
		Op()
		Expression()
	)?
}
*/

void VarList() :
{
	Token t;
}
{
	Var()
	(
		VarList()
	)?
}

void Var()      :
{/*@bgen(jjtree) Var */
        ASTVar jjtn000 = new ASTVar(JJTVAR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Var */
        try {
/*@egen*/
	t = <VAR>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setId(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



void QSet() :
{
}
{
	Quant()
	<LSP>
	VarList()
	<RSP>
}
