/* Qbf_parser.jj
 * Parses a quantified boolean formula in QBF Format 1.0
 * as specified at http://www.qbflib.org/boole.html
 *
 *	<input>		::= <exp> EOF
 *	<exp>		::= <NOT> <exp> | <q_set> <exp> | <LP> <exp> <op> <exp> <RP>
 *				| <LP> <exp> <RP> | <VAR>
 *	<q_set> 	::= <quant> <LSP> <var_list> <RSP>
 *	<quant> 	::= <EXISTS> | <FORALL>
 *	<var_list> 	::= <VAR> <var_list> | <VAR>
 *	<op>		::= <OR> | <AND>
 *	<NOT>		::= "!"
 *	<LP>		::= "("
 *	<RP>		::= ")"
 *	<LSP>		::= "["
 *	<RSP>		::= "]"
 *	<OR>		::= "|"
 *	<AND>		::= "&"
 *	<EXISTS> 	::= "exists"
 *	<FORALL> 	::= "forall"
 *	<VAR>		::= {A sequence of non-special ASCII characters} 
 */

options {
	MULTI = true;
	VISITOR = true;
	NODE_DEFAULT_VOID=true;
}

PARSER_BEGIN(Qbf_parser)
package main.java.logic.parser;

import java.util.Vector;
import java.util.regex.Pattern;

class Qbf_parser {

	private static Vector<Integer> eVars = new Vector<Integer>();
	private static Vector<Integer> aVars = new Vector<Integer>();
	private static Vector<Integer> vars = new Vector<Integer>();

// +---
// | just for testing
// |
	public static void main(String args[]) throws ParseException,TokenMgrError {
		Qbf_parser parser = new Qbf_parser(System.in);
		try {
			ASTStart n = parser.Start();
			Qbf_parserVisitor v = new Qbf_parserDumpVisitor();
			n.jjtAccept(v, null);					
			System.out.println("vars: "+vars);
			System.out.println("eVars: "+eVars);
			System.out.println("aVars: "+aVars);		

			System.out.println(printAsQpro(n));
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println(e.getMessage());
			System.out.println("Something went wrong while parsing.");
		}		
	}
	
	// Convert the internal representation of a QBF to a String that Qpro can work with
	public static String printAsQpro(ASTStart s) {
		Node n = (Node) s;
		Node current = n;
		int child = 0;
		int i = 0;
		int numNodes = n.jjtGetNumChildren();
		int numVars = vars.size();
		int numOpenQuantifiers = 0;
		int processedNodes = 0;
		String returnString = "";
		String tmp = "";
		
		// QPro Header
		// returnString += "c We could add comments like this at the beginning"
		// returnString += "c if necessary."
		returnString += "QBF\n";
		returnString += numVars;
		returnString += "\n";		
		
		// The root node is not really part of our formula, so just skip it.
		if (n.toString().equals("Start")) {
			current = n.jjtGetChild(child);
			processedNodes++;
		}
		
		// Traverse through the rest of the tree, until all nodes are processed.
		while (processedNodes < numNodes) {
		
			// Quantifiers and their variables
			// q
			// e 1
			// a 2 3 4
			// ....
			// /q
			if(current.toString().equals("Quant")) {
				returnString += "q";

				while (current.toString().equals("Var") || current.toString().equals("Quant")) { 

					if (current.toString().equals("Quant") && current.getId() == 0) {
						returnString += "\na ";
						processedNodes++;
					}					
					if (current.toString().equals("Quant") && current.getId() == 1) {
						returnString += "\ne ";
						processedNodes++;
					}
					
					child++;
					current = n.jjtGetChild(child);

					while (current.toString().equals("Var")) {
						returnString += current.getId() + " ";
						processedNodes++;
						child++;
						current = n.jjtGetChild(child);				
					}
				}
				
				returnString += "\n/q\n";

			}

			// Variables			
			if(current.toString().equals("Var")) {
				returnString += current.getId();
				returnString += " ";
				processedNodes++;
			}
			
			// Conjunction
			if(current.toString().equals("And")) {
				returnString += "c ";
				processedNodes++;
			}
			
			// Disjunction
			if(current.toString().equals("Or")) {
				returnString += "d ";
				processedNodes++;
			}
			
			// Negation
			if(current.toString().equals("Not")) {
				processedNodes++;
			}
		
			child++;	
			if (child < numNodes)
				current = n.jjtGetChild(child);			
		}				
				
		// return the QBF in QPro format
		return returnString;
	}
// |
// | end of testing
// +---

	/**
	* getter method for variable numbers
	* @return a Vector<Integer> containing all variable numbers
	*/	
	public Vector<Integer> getVars() {
		return vars;
	}

	/**
	* getter method for all variables bound by an exists-quantifier
	* @return a Vector<Integer> containing variable numbers
	*/	
	public Vector<Integer> getEVars() {
		return eVars;
	}

	/**
	* getter method for all variables bound by an all-quantifier
	* @return a Vector<Integer> containing variable numbers
	*/	
	public Vector<Integer> getAVars() {
		return aVars;
	}
}
PARSER_END(Qbf_parser)

SKIP : {" "}
SKIP : {"\n" | "\r" | "\r\n" }

TOKEN : { < AND		: "&" > }
TOKEN : { < OR		: "|" > }
TOKEN : { < NOT		: "!" > }

TOKEN : { < LP		: "(" > }
TOKEN : { < RP		: ")" > }
TOKEN : { < LSP		: "[" > }
TOKEN : { < RSP		: "]" > }

TOKEN : { < EXISTS	: "exists" > }
TOKEN : { < FORALL	: "forall" > }

TOKEN : { < VAR		: (["a"-"z"])(["0"-"9"])+ > }

ASTStart Start() #Start :
{
}
{
/*DEBUG*/ {System.out.println("Starting parsing.");} /*DEBUG*/ 
	Expression() 
/*DEBUG*/ {System.out.println("Finished parsing. ");} /*DEBUG*/ 
	<EOF>
	{return jjtThis;}
}

String Quant() #Quant :
{
}
{
	<FORALL> {jjtThis.setId(0); return "forall";}
	|
	<EXISTS> {jjtThis.setId(1); return "exists";}
}

void Op() :
{
}
{
	And()
	|
	Or()
}

void And() #And(2) :
{
}
{
	<AND>
}

void Or() #Or(2) :
{
}
{
	<OR>
}

void Not() #Not :
{
}
{
	<NOT>
}

void Expression() :
{
}
{
	Not()
	Expression()
	|
	QSet()
	Expression()
	|
	<LP>
	Expression()
	(
		Op()
		Expression()
	)?
	<RP>
	|
	Var("")
}

void VarList(String s) :
{
	Token t;
}
{
	Var(s)
	(
		VarList(s)
	)?
}

void Var(String s) #Var :
{
	Token t;
}
{
	t = <VAR>
	{	// Stripping down the variable name to a number (e.g. "v123" -> 123 and
		// adding it to a vector containing all variable numbers as well as to a
		// vector with all exist- or allquantified variables (that's the reason
		// for the funny String s fallthrough)
		String varName = t.image.replaceAll("[a-z]*","");
		int varNumber = Integer.valueOf(varName).intValue();
		jjtThis.setId(varNumber);
		if (s == "exists")
			eVars.add(varNumber);
		if (s == "forall")
			aVars.add(varNumber);
		if (s == "")
			vars.add(varNumber);

	}
}

void QSet() :
{
	String s;
}
{
	s = Quant()
	<LSP>
	VarList(s)
	<RSP>
}
