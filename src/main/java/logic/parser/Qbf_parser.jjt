/* Qbf_parser.jj
 * Parses a quantified boolean formula in QBF Format 1.0
 * as specified at http://www.qbflib.org/boole.html
 *
 *	<input>		::= <exp> EOF
 *	<exp>		::= <NOT> <exp> | <q_set> <exp> | <LP> <exp> <op> <exp> <RP>
 *				| <LP> <exp> <RP> | <VAR>
 *	<q_set> 	::= <quant> <LSP> <var_list> <RSP>
 *	<quant> 	::= <EXISTS> | <FORALL>
 *	<var_list> 	::= <VAR> <var_list> | <VAR>
 *	<op>		::= <OR> | <AND>
 *	<NOT>		::= "!"
 *	<LP>		::= "("
 *	<RP>		::= ")"
 *	<LSP>		::= "["
 *	<RSP>		::= "]"
 *	<OR>		::= "|"
 *	<AND>		::= "&"
 *	<EXISTS> 	::= "exists"
 *	<FORALL> 	::= "forall"
 *	<VAR>		::= {A sequence of non-special ASCII characters} 
 */

options {
	MULTI = true;
	NODE_DEFAULT_VOID = true;
	// VISITOR = true;
}

PARSER_BEGIN(Qbf_parser)

package main.java.logic.parser;
import java.util.Vector;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.io.*;

public class Qbf_parser {

	private static Vector<Integer> eVars = new Vector<Integer>();
	private static Vector<Integer> aVars = new Vector<Integer>();
	private static Vector<Integer> vars  = new Vector<Integer>();
	private static HashMap<Integer, Integer> literalCount  = new HashMap<Integer, Integer>();
	private static Node root = null;
	
	public HashMap<Integer, Integer> getLiteralCount() {
		return literalCount;
	}

	public Vector<Integer> getEVars() {
		return eVars;
	}

	public Vector<Integer> getAVars() {
		return aVars;
	}

	public Vector<Integer> getVars() {
		return vars;
	}

	public SimpleNode getRootNode() {
		return (SimpleNode)root;
	}

	// TODO DO THE STUFF AT THE RIGHT PLACE Qbf.java might be good
	public static void main(String[] args) {
		Qbf_parser parser;

		try {
			parser = new Qbf_parser(new FileInputStream(args[0]));
		}
		catch (FileNotFoundException e) {
			System.out.println("File not found: " + args[0]);
			return;
		}

		try {
			parser.Input();
			System.out.println("Succesful parse");
			root = parser.jjtree.rootNode().jjtGetChild(0); 

			root.dump("");
/*			root.assignTruthValue(2,true);*/

		// reducing tree begin
			boolean reducable = true;
			System.out.println("reducing tree begin");
			while (reducable) {
				reducable = root.reduceTree();	
			};
			System.out.println("reducing tree end");
		// reducing tree end

		// Convert internal tree to .qpro format
			String traversedTree = root.traverse();

			System.out.print(
				"\nQBF\n" + 
				(vars.size()+1) + 
				"\nq\n" + 
				"a "
			);
			for (int i=0; i < eVars.size(); i++) System.out.print(eVars.get(i) + " ");
			System.out.print(
				"\n" + 
				"e ");
				for (int i=0; i < aVars.size(); i++) System.out.print(aVars.get(i) + " "
			);
			System.out.println("");
			System.out.println(
				traversedTree + 
				"/q\nQBF\n"
			);
		// Conversion end

			// TODO REMOVE JUST DEBUG INFO AND setTruth() test
			System.out.println("\nDEBUG INFO\n");
			root.dump("");
			System.out.println("");				
			System.out.println("vars: " + vars);
			System.out.println("all-quantified vars: " + aVars);
			System.out.println("exists-quantified vars: " + eVars);
			System.out.println("hashmap: " + literalCount);
			
			
/*			root.setTruthValue(1,false);*/
/*			root.setTruthValue(3,true);*/
/*			traversedTree = root.traverse();*/
			// TODO REMOVE JUST DEBUG INFO END
		}
		catch (ParseException e) {
			System.out.println("Parse error");			
			System.out.println(e);
			return;
		}
		catch (TokenMgrError e) {
			System.out.println("Token error");			
			System.out.println(e);
			return;
		}

	}
}

PARSER_END(Qbf_parser)

SKIP : {" "}
SKIP : {"\n" | "\r" | "\r\n" }

// terminals
TOKEN : { < AND		: "&" > }
TOKEN : { < OR		: "|" > }
TOKEN : { < NOT		: "!" > }

TOKEN : { < LP		: "(" > }
TOKEN : { < RP		: ")" > }
TOKEN : { < LSP		: "[" > }
TOKEN : { < RSP		: "]" > }

TOKEN : { < EXISTS	: "exists" > }
TOKEN : { < FORALL	: "forall" > }

TOKEN : { < VAR		: (["a"-"z"])(["0"-"9"])+ > }

// non-terminals
// *	<input>		::= <exp> EOF
void Input() #Input:	// Node with one child (Exp())
{}
{
	Exp()
	<EOF>
}

// *	<var_list> 	::= <VAR> <var_list> | <VAR>
//{}
//{
////	Var()
////	|
////	Var()
//}

void And() #And:	// Node with two children (Exp(), Exp())
{}
{       
	<AND> { jjtThis.op = "&"; } 
}

void Or() #Or:	// Node with two children (Exp(), Exp())
{}
{
	<OR> { jjtThis.op = "|"; }
}

void Not():	// Node with one child (Exp())
{}
{
 	<NOT>
}
void Exists():
{}
{
	<EXISTS>// { jjtThis.op = "e"; }
}

void Forall():
{}
{
	<FORALL>// { jjtThis.op = "f";}
}

void Var() #Var:
{
	Token t;
}
{
	t = <VAR>
	{	// Stripping down the variable name to a number (e.g. "v123" -> 123 and
		// adding it to a vector containing all variable numbers as well as to a
		// vector with all exist- or allquantified variables (that's the reason
		// for the funny String s fallthrough)
		String varName = t.image.replaceAll("[a-z]*","");
		int varNumber = Integer.valueOf(varName).intValue();
		varNumber++;
		jjtThis.var = varNumber;
/*		if (s == "e") {*/
/*			eVars.add(varNumber);*/
/*		}*/
/*		if (s == "f") {*/
/*			aVars.add(varNumber);*/
/*		}*/
/*		if (s == "") {*/
			
			if (literalCount.get(varNumber) != null) {
				literalCount.put(varNumber, literalCount.get(varNumber) + 1);
			}
			else {
				literalCount.put(varNumber, 1);			
			}	
			if (!vars.contains(varNumber)) {
				vars.add(varNumber);
			}
/*		}*/
	}
}

void VarQ(String s):
{
	Token t;
}
{
	t = <VAR>
	{	// Stripping down the variable name to a number (e.g. "v123" -> 123 and
		// adding it to a vector containing all variable numbers as well as to a
		// vector with all exist- or allquantified variables (that's the reason
		// for the funny String s fallthrough)
		String varName = t.image.replaceAll("[a-z]*","");
		int varNumber = Integer.valueOf(varName).intValue();
		varNumber++;
		if (s == "e") {
			eVars.add(varNumber);
		}
		if (s == "f") {
			aVars.add(varNumber);
		} 
	}
}

// *	<exp>		::= <NOT> <exp> | <q_set> <exp> | <LP> <exp> <op> <exp> <RP>
// *				| <LP> <exp> <RP> | <VAR>
void Exp() #void:
{
	String op = "";
}
{
	(
		Not() { jjtThis.op = "!"; }
		Exp()
	) #Logical(1)
	|
	Q_set()
	Exp()
	|
	<LP>
	(
		Exp()
		(
			(
				"|" {jjtThis.op = "|"; }
				|
				"&" {jjtThis.op = "&"; }
			)
			Exp()
		)?
	) #Logical(>1)  
	<RP>
	|
	Var()
//	|
//	<EOF>
}

// *	<q_set> 	::= <quant> <LSP> <var_list> <RSP>
void Q_set() #void:
{
	String s;
}
{
	s = Quant()
	<LSP>
	VarQ(s)
	<RSP>
}

// *	<quant> 	::= <EXISTS> | <FORALL>
String Quant() #void:
{}
{
	Exists() { return "e"; }
	|
	Forall() { return "f"; }
}

// *	<op>		::= <OR> | <AND>
void Op() #void:
{}
{
	Or()
	|
	And()
}

